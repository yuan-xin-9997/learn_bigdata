dws
    汇总层

    轻度汇总
        小窗口级别的汇总

        0-10
        10-20
        20-30

    存储轻度汇总结果的介质，应该是支持SQL的数据库
        mysql   oltp数据库，不适合大数据量
        hive  查询延时太高，不适合于实时查询
        hbase+phoenix    适合
        clickhouse       适合
        doris            适合          ref https://doris.apache.org/zh-CN/docs/gettingStarted/what-is-new

        要求：能够实时查询、数据量要大

ads层
    根据具体时间进一步的汇总

    使用SQL语句
        select ... sum() .. from t where time >= ...  and time <= ...




10.1 流量域来源关键词粒度页面浏览各窗口汇总表
搜索记录  找到用户的搜索关键词，统计关键词在每个窗口内出现的次数

数据源
    页面日志
        "item" is not null  "item_type"="keyword" "last_page_id" = "search"

    "华为手机
    小米手机
    苹果手机"

    对关键词进行分词，IK分词器
    "华为手机"  "华为" "手机" ...

    开窗聚合，统计每个关键词的次数
        group window
        tvf  √
        over

    把统计结果写到doris




统计七日回流用户和当日独立用户数
数据源：
    日志数据
        页面日志
什么样的数据？
    当日独立用户数：今天登录的用户  计数
    七日回流用户：今天登录的用户中，上一次登录距离今天超过7天
具体的计算：
    肯定用到状态




统计各窗口注册用户数，写入doris
数据源：
    注册事务事实表（从mysql中user_info表中的新增数据）


统计各窗口加购独立用户数
数据源：
    dwd层的加购事务事实表
统计加购独立用户数：
    按照user_id分组
    找到第一条记录
    开窗聚合
    写出到doris


统计当日支付成功独立用户数和首次支付成功用户数
日支付成功独立用户数：当日有多少用户支付成功
首次支付成功用户数：当日是用户在平台第一次支付成功
数据源：
    dwd层的支付事务事实表
计算：
    使用状态：存储用户最后一次成功支付的年月日
    这次支付成功的年月日和最后一次做对比
        如果不一样，则进入第一次支付成功 ...
        如果最后一次的日期是null，表示首次支付成功


交易域SKU粒度下单各窗口汇总表
数据源：
    dwd层的下单事务事实表
实现思路:
    按照sku_id分组，开窗，聚合各个指标
        总的销售额
    结果写出到doris中
1. 去重问题
    下单事务事实表来源于预处理表
        做了个过滤
    预处理表如何实现？
        order_detail join
        order_info left join
        详情活动 left join
        详情优惠券 look up join
        字典表
    因为有left join，对消费者来说，同一个详情可能会产生重复数据，
    现在是sku粒度，必须去重
    最后1条数据最全
    去重思路：
        数据最全的那条记录

    1. 用会话窗口
        row_op_ts 时间最大的那个
        把同一详情id的分组，开窗，取时间最大的那个
        什么窗口？
            把最多3条数据放入到同一个窗口
            这最多3条数据，从时间上来说，差距不会太大
            当下单的时候，详情和活动，优惠券几乎同时生成，可能由于网络的原因，导致的差别，5s足够
            会话窗口 gap=5s
            等到窗口触发计算的时候，找到时间最大的那个
    2. 用定时器
        同一个详情id，第一条数据进来的时候，注册1个5s后触发的定时器
        每来1条数据，把数据存入到状态中，后面来的数据和状态中的数据做比较，时间变大，则更新状态
        等到定时器触发的时候，则最大的比较出来

    会话窗口和定时器两种方法，哪种更好：定时器时效好，会话窗口实现简单，但是时效性更差。综合，定时器更好

    3. 如果在统计聚合计算的时候，根本就用不到右表的数据，就不需要等最全的了
        直接用第1条数据

2. 如何补充其他维度
    维度在什么地方？ hbase中(Phoenix)
    根据id查找对于的表得到维度
    执行：select ... from t where id=?
    每来1条数据，就需要去hbase中查找对应的维度  6张维度表：
        sku_info base_trademark spu_info 1\2\3级品列表
    聚合前查找维度，还是聚合后查找维度？
        聚合后，效率更搞




















