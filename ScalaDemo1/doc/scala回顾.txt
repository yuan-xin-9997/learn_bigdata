1、变量和数据类型
	1、变量和常量
		1、语法: val/var 变量名:类型 = 值
		2、val与var的区别
			val修饰是常量,代表值不可变,类似java final修饰的
			var修饰的是变量,代表值可变,类似java非final修饰的
		3、在定义变量/常量的时候,类型可以省略的,省略之后scala会自动推断。
		4、在定义变量/常量的时候必须初始化
	2、标识符的命名规范
		scala的标识符要求必须是数字、字母、下划线、$、特殊符号,首字母不能是数字。
		工作中标识符不推荐使用特殊符号,采用驼峰原则、见名知意原则
	3、字符串获取
		1、双引号包裹: "hello"
		2、new关键字获取: new String("....")
		3、通过toString、SubString等方法获取
		4、拼接
			1、通过+拼接: "aa" + "bb"
			2、通过插值表达式拼接: s"...${变量名/表达式/值}..."
		5、三引号: """......""" [一般用于写sql语句]
	4、数据类型
		scala是完全面向对象
		Any: 所有类的父类
			AnyVal: 值类型
				Byte、Short、Int、Float、Double、Long、Char、Boolean
				Unit: 相当于java的void,有一个实例()
				Stringops: 对java字符串扩展的统称
			AnyRef: 引用类型
				String、java数组\集合\class、scala数组\集合\class
					Null: 是所有引用类型的子类,有一个实例null,null一般用于给引用类型赋予初始值,在赋予初始值的时候必须指定变量类型。
		Nothing: 所有类型的子类
	5、类型转换
		1、数字与数字的转换
			1、低精度转高精度[Int->Long]: 自动转换
			2、高精度转低精度[Long->Int]: toXXX方法
		2、数字与字符串的转换
			1、数字转字符串: 拼接、toString
			2、字符串转数字: toXXX方法
2、运算符
	scala的运算符
		算术运算符: + - * / %
		关系运算符: > < >= <= == !=
		逻辑运算符: && || !
		位运算符: << >> >>> & | ^
		赋值运算符: += -= *= /=
	scala的运算符没有++、--、三元运算符。
	scala的==是比较值是否相等,相当于java的equals
	scala的运算符其实是一个个的方法
	scala方法调用的两种方式
		1、对象.方法名(参数值,...)
		2、对象 方法名 (参数值,...) [方法如果只有一个参数,()可以省略]
3、流程控制
	1、块表达式
		1、定义: 由{}包裹的一段代码就称之为块表达式
		2、块表达式有返回值,返回值是{}中最后一个语句的执行结果
	2、scala的流程控制语句没有switch
	3、分支控制
		单分支: if(...){...}
		双分支: if(...){...} else {...}
		多分支: if(...){...} else if(...){...}.... else{...}
		if语句有返回值,返回值是符合条件的分支的块表达式的结果值
	4、for循环
		两个方法
			to方法
				使用: start.to(end[,step=1]) / start to (end,step)
				to生成的是左右闭合的集合
			until方法
				使用: start.until(end[,step=1]) / start until (end,step)
				until生成的是左闭右开的集合
		for循环基本语法: for(变量名<- 集合/数组/表达式) {...}
		for循环的守卫: for(变量名<- 集合/数组/表达式 if(布尔表达式)) {...}
			每次遍历的时候会先对变量判断,如果满足要求才会执行循环体
		yield表达式: for循环的循环体块表达式默认没有返回值,此时可以使用yield让for的循环体有返回值
			语法: for(变量名<- 集合/数组/表达式) yield{...}
	5、while与do-while
		scala while与do-while与java完全一样
	6、break与continue
		scala没有break与continue关键字
		scala实现break:
			1、导入import scala.util.control.Breaks._
			2、使用breakable与break方法实现
				breakable({
					for(...){
						...
						if(...) break()
						...
					}
				})
		scala实现continue:
			1、导入import scala.util.control.Breaks._
			2、使用breakable与break方法实现
				for(...){
					breakable({
						...
						if(...) break()
						...
					})
				}
4、函数式编程
	1、方法
		1、语法: def 方法名(参数名:类型,...):返回值类型 = {方法体}
		2、方法的简化
			1、如果方法体只有一行语句,方法体的{}可以省略
			2、如果要将方法体块表达式的结果值作为方法的返回值,方法值类型可以省略
				注意: 如果方法体中有return关键字,返回值类型必须指定
			3、如果方法不需要返回值, =可以省略 [ =与{}不能同时省略 ]
			4、如果方法不需要参数,参数列表的()可以省略的
				注意:
					1、如果定义方法的时候省略了(),调用方法的时候()不能带上
					2、如果定义方法的时候没有省略(),调用方法的时候()可有可无
		3、方法的参数
			1、默认值参数: 在定义方法的时候给方法的参数指定默认值,有默认值的参数在后续调用方法的可以不用传值。
				语法: def 方法名(参数名:类型=默认值,...):返回值类型 = {方法体}
			2、带名参数: 在调用方法的时候指定将值传递给哪个参数：
				调用语法: 方法(参数名=值,...)
			3、可变参数: 在定义方法的时候指定参数为可变参数,后续调用方法的时候可以给该参数传任意多个指定类型的值。
				语法: def 方法名(参数名:类型,...,参数名:类型*):返回值类型 = {方法体}
					注意:
						1、可变参数必须放在参数列表的最后面
						2、可变参数不能与默认值参数一起使用
						3、可变参数不能直接传递数组/集合,如果想要将数组/集合的元素传递给可变参数,可以使用 数组名:_* 的方式传递
	2、函数
		1、语法: val/var 变量名[:类型] = (参数名:类型,....) => {函数体}
		2、函数是对象,函数的类型: (参数类型,...) => 返回值类型
		3、函数的简化: 如果函数体只有一行语句,函数体的{}可以省略
	3、方法和函数的区别
		1、方法如果定义在class/object中是可以重载的,函数是对象,函数名就是变量名,统一作用域不允许有同名变量,所以函数不能重载
		2、方法存储在方法区中,函数是对象存储在堆中
	4、方法和函数的联系
		1、方法如果定义在方法中,其实就是函数,不能重载
		2、方法可以手动转成函数,可以通过 方法 _ 的形式转换。
	5、高阶函数
		1、定义: 以函数作为参数/返回值的方法/函数称之为高阶函数
			def m1(x:Int,y:Int,func: (Int,Int)=>Int ) = func(x,y)
			val func = (a:Int,b:Int) => a * b
			m1(10,20,func)
		2、高阶函数的简化
			1、直接传递函数值: m1(10,20,(a:Int,b:Int) => a * b)
			2、函数的参数类型可以省略的: m1(10,20,(a,b) => a * b)
			3、如果函数只有一个参数,参数列表的()可以省略:
				def m2(x:Int,func: Int=>Int) = func(x)
				m2(10,x=>x*10)
			4、如果函数的参数在函数体中仅使用了一次可以用_代替: m1(10,20,_ * _ )
				以下三种情况不能用_简化:
					1、针对是函数有多个参数的情况: 如果函数参数的使用顺序与定义顺序不一致,此时不能用_简化[第N个下划线代表函数第N个参数]
						m1(10,20,(x,y)=>y-x) 不能简化为 m1(10,20,_ - _)
					2、针对函数体中有()并且函数的参数在()中以表达式形式存在,不能简化
						m1(10,20,(x,y)=>(x*10)+y) 不能简化为 m1(10,20,(_*10)+_)
						m1(10,20,(x,y)=>(x)*y) 能简化为 m1(10,20,(_)+_)
					3、针对函数只有一个参数的情况: 如果函数只有一个参数,并且在函数体中没有任何操作直接返回函数参数,此时不能用_简化
						m2(10,x=>x) 不能简化 m2(10,_)
	6、匿名函数
		定义: 没有函数名的函数称之为匿名函数
		匿名函数一般用于给高阶函数传值使用: m1(10,20,(x,y)=>y-x)
	7、函数的柯里化
		定义: 有多个参数列表的方法称之为柯里化
		语法: def 方法名(参数名:类型,...)(参数名:类型,...)...:返回值类型 = {方法体}
	8、闭包
		定义: 函数体中使用了外部变量的函数称之为闭包
		val a = 10
		val func = (x:Int) => x * a
	9、递归
		定义: 自己调用自己
		前提
			1、必须要有退出条件,不能死循环
			2、必须要指定返回值类型
5、面向对象
	1、类的定义
		语法: [访问修饰符] class 类名{...}
	2、创建对象: new 类名(....)
	3、类的属性与方法的定义
		1、语法: [访问修饰符] val/var 属性名:类型 = 值
			var修饰的属性可以使用_赋予初始值,此时必须指定属性的类型: var name:String = _
		2、访问修饰符
			scala没有public,默认就是public
			scala的修饰符有: private、protect、private[包名]
				private[包名]：代表只能在指定包中使用,其他包无法使用
		3、方法的定义语法: [访问修饰符] def 方法名(参数名:类型,...):返回值类型 = {...}
	4、构造器
		scala的构造器分为两种:
			主构造器
				定义位置: 定义在类名后面,以()形式表示
				语法: class 类名([访问修饰符] [val/var] 属性名:类型[=默认值],...)
					主构造器中的属性使用val/var修饰与不使用val/var修饰的区别:
						使用val/var修饰的非private属性可以在class内部、外部都可以使用
						不用val/var修饰的属性只能在class内部使用
			辅助构造器
				定义位置: 定义在class内部
				语法:
					def this(参数名:类型,...){
						//辅助构造器第一行必须调用其他的辅助构造器或者主构造器
						this(...)
					}
	5、scala的object
		scala的object修饰的是单例的,只有唯一一个对象
		scala获取object的单例对象: object名称
		scala中object中所有成员都是类似java static修饰的,可以使用 object名称.成员名 调用
		scala中class中所有成员都是类似java 非static修饰的,可以使用 对象.成员名 调用
	6、伴生类[class]和伴生对象[object]
		伴生类与伴生对象的前提:
			1、class与object名称必须一样
			2、class与object必须在同一个.scala源文件中
		特性: 伴生类和伴生对象可以互相访问对方的私有成员
	7、apply方法
		apply必须定义在object中
		apply方法主要是用于简化class对象的创建
			def apply(...) = new XXX(..)
		定义apply方法之后,可以通过 object名称.apply(...) / object名称(...) 来创建class对象。
	8、类型检查和转换
		判断对象是否属于某个类型: 对象.isInstanceOf[类型]
		将对象强制转换成某个类型: 对象.asInstanceOf[类型]
		获取对象的class形式: 对象.getClass
		获取类的class形式: classOf[类名]
6、集合
	scala的集合分为两种
		可变集合: 集合的长度可变,意味着可以在原集合中添加/删除元素[scala.collection.mutable]
			可变数组
				1、创建方式
					1、通过new方式: new ArrayBuffer[元素类型]()
					2、通过apply方法: ArrayBuffer[元素类型](初始元素,...)
				2、获取指定角标的元素: 数组名(角标)
				3、修改指定角标的值: 数组名(角标) = 值
			可变List
				1、创建方式
					1、通过new方式: new ListBuffer[元素类型]()
					2、通过apply方法: ListBuffer[元素类型](初始元素,...)
				2、获取指定角标的元素: 数组名(角标)
				3、修改指定角标的值: 数组名(角标) = 值
			可变Set
				1、创建方式
					1、通过apply方法: mutable.Set[元素类型](初始元素,...)
			可变Map
				1、创建方式
					1、通过apply方法: mutable.Map[K的类型,V的类型]( k->v, (k,v),... )
				2、添加元素: put(key,value)
				3、删除元素: remove(key)
				4、获取key对应的value值: getOrElse(key,默认值) [如果key在map中存在则返回value值,如果不存在则返回默认值]
				5、修改元素: 集合名(key) = value
			可变队列
				1、创建方式
					1、通过apply方法: mutable.Queue[元素类型](初始元素,...)
				2、添加元素: enqueue(元素)
				3、删除元素: dequeue
				4、获取指定角标的元素: 集合名(角标)
				5、修改指定角标的值: 集合名(角标) = 值
		不可变集合: 集合的长度不可变,意味着不可以在原集合中添加/删除元素[scala.collection.immutable]
			不可变数组
				1、创建方式
					1、通过new方式: new Array[元素类型](数组的长度)
					2、通过apply方法: Array[元素类型](初始元素,...)
				2、获取指定角标的元素: 数组名(角标)
				3、修改指定角标的值: 数组名(角标) = 值
				4、创建多维数组: Array.ofDim[元素类型](行数,列数)
			不可变List
				1、创建方式
					1、通过apply方法: List[元素类型](初始元素,...)
				2、添加元素的方法
					:: 代表将单个元素添加在集合最前面
						::如果使用空格调用,最右边必须是不可变List或者Nil
						Nil是代表空的不可变List
					::: 代表将一个指定集合所有元素添加在集合最前面
				3、获取指定角标的元素: 数组名(角标)
				4、修改指定角标的值: 数组名.updated(角标) = 值 [updated是生成新集合,原集合元素没有改变]
			不可变Set
				1、创建方式
					1、通过apply方法: Set[元素类型](初始元素,...)
			不可变Map
				1、创建方式
					1、通过apply方法: Map[K的类型,V的类型]( k->v, (k,v),... )
				2、获取key对应的value值: getOrElse(key,默认值) [如果key在map中存在则返回value值,如果不存在则返回默认值]
				3、修改元素: 集合名.updated(key,value)  [updated是生成新集合,原集合元素没有改变]
			不可变队列
				1、创建方式
					1、通过apply方法: Queue[元素类型](初始元素,...)
				2、添加元素: enqueue(元素) [生成新集合,原集合没有改变]
				3、删除元素: dequeue [生成新集合,原集合没有改变]
				4、获取指定角标的元素: 集合名(角标)
				5、修改指定角标的值: 集合名.updated(角标,元素)
		元组:
			创建方式:
				1、通过()的方式创建[可以用于创建任意元组]: (初始元素,...)
				2、通过->的方式创建[只能用于二元元组创建]: K -> V
				scala二元元组代表KV键值对
			元组最多只能存放22个元素
			元组一旦创建,元组元素个数与元素都不可变
			元组获取元素: 元组名._N [N相当于元组元素的角标,角标从1开始]
		集合通用的添加[+:、:+、+=、+=:、++、++=、++:、++=:]/删除[-、-=、--、--=]的方法的区别
			带+与带-的方法的区别:
				带+是添加元素
				带-是删除元素
			带=与不带=的方法的区别
				带=是在原集合中添加/删除元素
				不带=是生成一个新集合,原集合数据没有改变
			不带冒号与冒号在前、冒号在后的区别
				冒号在前、不带冒号是将元素添加在集合最后面
				冒号在后是将元素添加在集合最前面
			一个+/-与两个+/-方法区别
				一个+/-是添加/删除单个元素
				两个+/-是将一个指定集合中所有元素全部添加/删除
		集合常用函数
			1、基本属性
				判断集合是否为空: isEmpty
				判断集合是否包含某个元素: contains
				获取集合长度: length/size
				将集合所有元素拼接成字符串: mkString(分隔符)
				将集合转成迭代器
					toIterator: 生成的是Iterator迭代器,只能使用一次
					toIterable: 生成的是Iterable迭代器,可以重复使用
			2、衍生集合
				去重: distinct
				删除前N个元素,获取剩余所有元素: drop(n)
				删除后N个元素,获取剩余所有元素: dropRight(n)
				获取前N个元素: take(n)
				获取后N个元素: takeRight(n)
				获取第一个元素: head
				获取最后一个元素: last
				获取除开第一个元素的所有元素: tail
				获取除开最后一个元素的所有元素: init
				反转: reverse
				获取指定角标范围的所有元素: slice(开始角标,结束角标)
				滑窗: sliding(窗口长度,滑动长度)
				求差集: diff
				交集: intersect
				并集: union
				拉链: zip
				反拉链: unzip
				将元素与角标拉链: zipWithIndex
			3、集合初级计算函数
				最大值: max
				最小值: min
				求和: sum
				根据指定字段获取最大元素: maxBy(func: 集合元素类型=>B)
					maxBy里面的函数是针对每个元素操作
					maxBy是根据函数的返回值获取最大元素
				根据指定字段获取最小元素: minBy(func: 集合元素类型=>B)
					minBy里面的函数是针对每个元素操作
					minBy是根据函数的返回值获取最小元素
				排序
					sorted: 根据元素本身排序[默认升序]
					sortBy(func: 集合元素类型=>B): 根据指定字段对集合元素排序
						sortBy里面的函数是针对每个元素操作
						sortBy是根据函数的返回值对集合元素排序
						sortBy默认升序
					sortWith(lt: (集合元素类型,集合元素类型)=>Boolean): 根据规则排序
						升序: 第一个参数<第二个参数
						降序: 第一个参数>第二个参数
			4、集合高级函数
				map(func: 集合元素类型=>B): 一对一映射[原集合一个元素计算得到新集合一个元素]
					map里面的函数是针对每个元素操作,元素有多少个,函数执行多少次
					map生成的新集合中元素个数 = 原集合元素个数
					map相当于有yield关键字的for循环
					map类似sql的select
					map的使用场景: 一般用于数据类型/值的转换[一对一转换]
				foreach(func: 集合元素类型=>B):Unit : 对每个元素遍历
					foreach里面的函数是针对每个元素操作,元素有多少个,函数执行多少次
					foreach与map的区别:
						map会生成新的集合
						foreach没有返回值
				flatten: 压平
					flatten是针对集合嵌套集合的数据类型
					flatten是将第二层集合压掉,元素保留
					flatten类似sql的explode
				flatMap(func: 集合元素类型=>集合) = map + flatten : 转换+压平
					flatMap里面的函数是针对每个元素操作,元素有多少个,函数执行多少次
					flatMap生成新集合,新集合元素个数一般来说是>=原集合元素个数
					flatMap的使用场景: 一对多
				filter(func: 集合元素类型=>Boolean): 按照指定条件过滤
					filter里面的函数是针对每个元素操作,元素有多少个,函数执行多少次
					filter是保留函数返回值为true的数据
					filter类似sql的where
					filter一般用于脏数据过滤
				groupBy(func: 集合元素类型=>K): 按照指定字段分组
					groupBy里面的函数是针对每个元素操作,元素有多少个,函数执行多少次
					groupBy是根据函数的返回值对集合元素进行分组
					groupBy生成的是Map集合,Map中的key是函数的返回值,Map的value是key在原集合中对应的所有元素的集合
					groupBy的使用场景: 多对一的分组场景
				reduce(func: (集合元素类型,集合元素类型)=>集合元素类型): 从左向右对集合所有元素聚合
					reduce函数第一个参数代表上一次聚合结果,如果是第一次聚合,初始值 = 集合第一个元素
					reduce函数第二个参数代表当前待聚合的元素
				reduceRight(func: (集合元素类型,集合元素类型)=>集合元素类型): 从右向左对集合所有元素聚合
					reduce函数第二个参数代表上一次聚合结果,如果是第一次聚合,初始值 = 集合最后一个元素
					reduce函数第一个参数代表当前待聚合的元素
				fold(默认值)(func: (集合元素类型,集合元素类型)=>集合元素类型): 从左向右对集合所有元素聚合
					reduce函数第一个参数代表上一次聚合结果,如果是第一次聚合,初始值 = 默认值
					reduce函数第二个参数代表当前待聚合的元素
				foldRight(默认值)(func: (集合元素类型,集合元素类型)=>集合元素类型): 从右向左对集合所有元素聚合
					reduce函数第二个参数代表上一次聚合结果,如果是第一次聚合,初始值 = 默认值
					reduce函数第一个参数代表当前待聚合的元素
7、模式匹配
	1、基本语法:
		变量 match {
			case 条件 => ....
			case 条件 => ....
			.....
			case x => ... //代表其他情况,类似switch的default语句

		}
		模式匹配有返回值,返回值是符合条件的分支的块表达式的结果值
	2、模式匹配常用的用法
		1、匹配类型
			变量 match {
				case x:类型1 => ....
				case x:类型2 => ....
				case x:类型3 => ....
				.....
			}
		2、匹配元组
			变量 match {
				case (x,y,z,...) => ...
			}
			变量是几元元组,匹配条件就只能是几元元组。
		3、匹配对象和样例类
			样例类
				语法: case class 类名([val/var] 属性名:类型[=默认值],...)
					如果属性没有使用val/var修饰,默认就是val修饰的
				创建样例类对象: 类名.apply(属性值,...) / 类名(属性值,...)
			样例类可以直接用于模式匹配
				case class Person(name:String,age:Int)
				val p = Person("lisi",20)
				p match {
					case Person(x,y) => ....
				}
			普通类的对象不能直接用于模式匹配,需要在伴生对象中定义unapply方法之后才能用于模式匹配
	3、偏函数
		1、定义: 没有match关键字的模式匹配就是偏函数
		2、语法
			val 函数名: IN => OUT = {
				case 条件1 => ...
				.....
			}
			或者
			val 函数名:PartialFunction[IN,OUT] = {
				case 条件 =>...
				.....
			}
			IN: 是函数参数类型[其实就是待匹配的变量的类型]
			OUT: 是函数的返回值类型[其实就是模式匹配的结果类型]
		3、用法
			偏函数在工作中一般是搭配map\filter\groupBy等方法结合元组匹配一起使用
			val list:List[(String,Int,String,(String,Int))] = ...
			list.map{
				case (x,y,z,(a,b)) => ...
			}
8、异常
	scala的异常处理方式
		捕获异常[工作常用]
			1、try{...}catch{case e:XXException => ....}finally{....} 【一般用于获取外部资源连接的场景,确保资源链接的关闭】
			2、Try(代码块).getOrElse(默认值) 【用于数据处理过程中可能出现的异常】
				Try代表当前代码块执行可能有异常
				Try有两个子类: Success、Failture
					Success代表代码执行成功
					Failture代表代码执行异常
				getOrElse: 如果代码执行成功则返回执行结果,如果执行异常则返回默认值
		抛出异常: 只需要在方法体中通过throw关键字抛出异常即可
9、隐式转换方法
	定义: 悄悄的将一个类型转成另一个类型
	语法:
		implicit def 方法名(参数名:待转换类型):目标类型 = {.....}
	隐式转换方法使用时机:
		1、当前类型与目标类型不一致: val d:Int = 2.2
		2、当对象使用了不属于自身的属性和方法的时候: val f:Person = ... ; f.xx()
	隐式转换的解析机制
		1、首先从当前作用域查询是否有符合要求的隐式转换,如果有则直接使用,如果没有则报错
		2、如果隐式转换定义在其他的Object/class中,此时需要导入之后才能使用
			1、如果隐式转换定义在object中,可以通过 import object名称._ / import object名称.隐式转换名称 导入使用
			2、如果隐式转换定义在class中,可以通过 import 对象._ / import 对象.隐式转换名称 导入使用